options {
    STATIC = true; // make parser methods static
    DEBUG_PARSER = true;
    LOOKAHEAD = 1;
}

PARSER_BEGIN(MidtermParser)
public class MidtermParser {
  public static void main(String[] args) throws ParseException {
    /*
    new MidtermParser(System.in).parse();
    */
    Exp e = new MidtermParser(System.in).parse();
    System.out.println(e + "");
    MidtermVisitor v = new MidtermVisitor();
    v.visit(e);
  }
}
PARSER_END(MidtermParser)

/*
E -> P (* P | / P)*
P -> F (^ P)?
F -> (E) | ID | RNUM
*/

SKIP : { " " | "\n" | "\t" | "\r" }

TOKEN : /* OPERATORS */
{
   < TIMES: "*" >
   | < DIVIDE: "/" >
   | < POWER: "^" >
   | < LRP: "(" >
   | < RRP: ")" >
   | < ID: "x" >
   | < RNUM: (["0"-"9"])+ | (["0"-"9"])+ "/" (["0"-"9"])+ >
}

/*
// Only Parser, No AST
void parse() : {}
{
    E() <EOF>
}

void E() : {}
{
    P() (<TIMES> P() | <DIVIDE> P())*
}

void F() : {}
{
    <LRP> E() <RRP> | <ID> | <RNUM>
}

void P() : {}
{
   F() (<POWER> P())?
}
*/

// AST
Exp parse(): {Exp e;}
{
   e = E() <EOF> {return e;} 
} 


Exp E(): {Exp e1,e2;}
{  
    e1=P()

    (
     <TIMES> e2= P() { e1=new Times(e1,e2);}
    |<DIVIDE> e2= P() { e1=new Divide(e1,e2);}
    )*

    {return e1;}
}

Exp P(): {Exp e1,e2;}
{  
    e1=F()
    [
     <POWER> e2 =P() { e1 = new Power(e1,e2);}
    ]

    {return e1;}
}

Exp F(): {Exp e1; Token t;}
{
    <LRP> e1 = E() <RRP> {return e1;}
    |t = <ID> {return new X(t.image);}
    |t = <RNUM>{return new RNum(t.image);}
}
